<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ezrilei.github.io</id>
    <title>my blog</title>
    <updated>2021-08-22T11:45:30.418Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ezrilei.github.io"/>
    <link rel="self" href="https://ezrilei.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://ezrilei.github.io/images/avatar.png</logo>
    <icon>https://ezrilei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, my blog</rights>
    <entry>
        <title type="html"><![CDATA[Solution：insert pdf to a blog page]]></title>
        <id>https://ezrilei.github.io/post/inser-pdf-to-a-blog-page/</id>
        <link href="https://ezrilei.github.io/post/inser-pdf-to-a-blog-page/">
        </link>
        <updated>2021-08-21T15:30:20.000Z</updated>
        <summary type="html"><![CDATA[<p>display pdf files via <code>Google Drive Viewer</code> API</p>
<pre><code>&lt;iframe src=&quot;https://docs.google.com/gview?embedded=true&amp;url=http://infolab.stanford.edu/pub/papers/google.pdf&quot; style=&quot;width:800px; height:500px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>display pdf files via <code>Google Drive Viewer</code> API</p>
<pre><code>&lt;iframe src=&quot;https://docs.google.com/gview?embedded=true&amp;url=http://infolab.stanford.edu/pub/papers/google.pdf&quot; style=&quot;width:800px; height:500px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
</code></pre>
<!-- more -->
<iframe src="https://docs.google.com/gview?embedded=true&url=http://infolab.stanford.edu/pub/papers/google.pdf" style="width:800px; height:500px;" frameborder="0"></iframe>
<hr>
<ul>
<li>将 github.com 替换为 raw.githubusercontent.com ，并去除 /blob ，即为该文件的下载链接。</li>
<li>将 <code>style=&quot;width:800px; height:500px;&quot;</code> 改为 <code>style=&quot;width: 95%; height: 500px;&quot;</code></li>
<li>增加居中<code>&lt;p align=&quot;center&quot;&gt;...&lt;/p&gt;</code></li>
</ul>
<pre><code>&lt;p align=&quot;center&quot;&gt;&lt;iframe src=&quot;https://docs.google.com/gview?embedded=true&amp;url=https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pdf/pdf/%E5%8F%91%E5%B1%95%E5%85%9A%E5%91%98%E6%9D%90%E6%96%99%E6%B8%85%E5%8D%95_v3.2-20210727.pdf&quot; style=&quot;width: 95%; height: 500px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
</code></pre>
<p align="center"><iframe src="https://docs.google.com/gview?embedded=true&url=https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pdf/pdf/%E5%8F%91%E5%B1%95%E5%85%9A%E5%91%98%E6%9D%90%E6%96%99%E6%B8%85%E5%8D%95_v3.2-20210727.pdf" style="width: 95%; height: 500px;" frameborder="0"></iframe></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/342135587">张晋, Typora嵌入视频和PDF</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Solution：MS excel 打印 跨页的 合并单元格 没有网格线]]></title>
        <id>https://ezrilei.github.io/post/add-grid-when-printing-merged-cell/</id>
        <link href="https://ezrilei.github.io/post/add-grid-when-printing-merged-cell/">
        </link>
        <updated>2021-08-20T13:00:03.000Z</updated>
        <summary type="html"><![CDATA[<img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108202137594.png" width = "75%" />]]></summary>
        <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108202137594.png" width = "75%" />
<!-- more -->
<h2 id="问题描述">问题描述</h2>
<p>打印 跨页的 合并单元格 会出现部分单元格没有网格线的情况</p>
<img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108201646751.png" width = "75%" />
<h2 id="解决方案">解决方案</h2>
<p>页边距 - 管理自定义页边距 - 页面设置 - 工作表 - 网格线☑️</p>
<img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108201650651.png" width = "25%" />
<!-- more -->
<img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108201651612.png" width = "50%" />
<h2 id="结果">结果</h2>
<p>跨页的 合并单元格 也会显示网格线了<br>
<img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108201652752.png" width = "75%" /></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用R语言批量写word文档]]></title>
        <id>https://ezrilei.github.io/post/write-word-doc-with-R/</id>
        <link href="https://ezrilei.github.io/post/write-word-doc-with-R/">
        </link>
        <updated>2021-07-06T00:26:22.000Z</updated>
        <summary type="html"><![CDATA[<p>需求描述：<br>
工作中，有时会遇到需要批量写word文档的时候，比如，写发展党员的批文的时候、临近节假日写困难党员慰问信的时候、发展对象培训班结业写证书、疫情期间打印通过审核的通行证的时候等等。这样的文档大部分内容是不变的，只有个别几个地方，需要写入信息。而这些信息可以很方便地以表格的形式呈现。</p>
<p>当然，我们可以挨个手动将信息填到word文档中，<br>
- 但是一来速度不快，要耗费大量时间；<br>
- 二来如果填写的量很大，容易induce human error——漏字、填错位等等。</p>
<p>解决方案：</p>
<ol>
<li>用MS word自带的<code>邮件合并（mail merge）</code>功能</li>
<li>用R语言的<code>officer::body_replace_all_text</code>函数</li>
</ol>
<p>本文介绍第二个方案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>需求描述：<br>
工作中，有时会遇到需要批量写word文档的时候，比如，写发展党员的批文的时候、临近节假日写困难党员慰问信的时候、发展对象培训班结业写证书、疫情期间打印通过审核的通行证的时候等等。这样的文档大部分内容是不变的，只有个别几个地方，需要写入信息。而这些信息可以很方便地以表格的形式呈现。</p>
<p>当然，我们可以挨个手动将信息填到word文档中，<br>
- 但是一来速度不快，要耗费大量时间；<br>
- 二来如果填写的量很大，容易induce human error——漏字、填错位等等。</p>
<p>解决方案：</p>
<ol>
<li>用MS word自带的<code>邮件合并（mail merge）</code>功能</li>
<li>用R语言的<code>officer::body_replace_all_text</code>函数</li>
</ol>
<p>本文介绍第二个方案。</p>
<!-- more -->
<h1 id="用r语言批量写word文档一-实现功能">用R语言批量写word文档（一）—— 实现功能</h1>
<h2 id="set-working-directory">set working directory</h2>
<pre><code class="language-{r}">#### set working directory ####
# set the folder where the RScript locates as working dir (you need Rstudio to do this)
setwd(
  dirname(rstudioapi::getSourceEditorContext()$path)
)
</code></pre>
<h2 id="load-packages">load Packages</h2>
<pre><code class="language-{r}">#### load Packages ####
library(readxl)
library(officer)
library(stringr)
</code></pre>
<h2 id="create-output-directory">create output directory</h2>
<pre><code class="language-{r}">#### create output dir ####
current.time &lt;- Sys.time() # 先把时间记下来 免得程序跑得过久 前后命名不一致
name.dir &lt;- paste0(&quot;output_&quot;,
                   format(current.time, &quot;%m%d_%H%M&quot;)
)
dir.create(name.dir)

path.tmp.dir &lt;- paste(&quot;.&quot;, name.dir, &quot;tmp/&quot;, sep = &quot;/&quot;)
dir.create(path.tmp.dir)
</code></pre>
<h2 id="load-ttinfo">load tt.info</h2>
<p>在R语言中，我们通常把变量（Variables）放在列（column），每一行（row）为一个Observation。</p>
<pre><code class="language-{r}">### load tt.info &lt;-----------------------
path.tt.info &lt;- &quot;./Data/【模拟】生活困难党员摸底统计.xlsx&quot;

tt.info &lt;- readxl::read_excel(path = path.tt.info,
                              sheet = 1, skip = 0
                              )
</code></pre>
<img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108220932708.png" width = "60%" />
<h2 id="write-word-docmument">write word docmument</h2>
<ul>
<li>
<p>首先制作模板.docx文件。将需要填入信息的位置，做好【标记】（如<code>namePerson</code>, <code>nameBank</code>, <code>account</code>)。</p>
<ul>
<li>
<p>★ 建议：将文字 一次性 粘贴到文档中，这样可以使【标记的内容】，位于word文档中的 同一个chunk 的 同一个node中。反之，如果对文档多次编辑，可能会使得【标记的内容】不在同一个node，此时<code>officer::body_replace_all_text</code>会识别不出来，提示：</p>
<pre><code> In x$doc_obj$replace_all_text(old_value, new_value, only_at_cursor,  :
  Found 0 instances of '...' in the document.
</code></pre>
</li>
<li>
<p>这里后面会写一篇文章，具体讨论这个问题。</p>
</li>
</ul>
</li>
<li>
<p>用<code>officer::read_docx</code>读取作为模板的.docx文件。</p>
<ul>
<li>.docx文件中的信息将以 类型（class）为<code>rdocx</code>的R object 储存</li>
<li>这里有个BUG：<code>officer_doc %&gt;% body_replace_all_text(...)</code>后，<code>officer_doc</code>会变成替换后的值（模板的值会被覆盖），故每一个Observation都必须重新读取一次模板。</li>
</ul>
  <img src="https://raw.githubusercontent.com/ezrilei/WhereThePicLay/pic/img/202108220924692.png" width = "80%" />
</li>
<li>
<p>用<code>officer::body_replace_all_text</code>把标记替换为要填入的文字。</p>
</li>
<li>
<p>最后用<code>print</code>函数把<code>rdocx</code>输出为pdf文件。</p>
</li>
</ul>
<pre><code class="language-{r}">#### write word documents ####
for(i in 1:nrow(tt.info)){
  # 读取 模板.docx &lt;-----------------------
  officer_doc &lt;- officer::read_docx(path = &quot;./Data/【模板】慰问信.docx&quot;)
  
  # def variable
  namePerson &lt;- tt.info$姓名[i]
  nameBank &lt;- tt.info$开户行名称[i]
  account &lt;- tt.info$`开户行账号（卡号）`[i] %&gt;% as.character()
  
  # 替换
  doc_replaced &lt;- officer_doc %&gt;%
    body_replace_all_text(old_value = &quot;namePerson&quot;, 
                          new_value = namePerson, 
                          only_at_cursor = FALSE
    ) %&gt;%
    body_replace_all_text(old_value = &quot;nameBank&quot;, 
                          new_value = nameBank, 
                          only_at_cursor = FALSE
    ) %&gt;% 
    body_replace_all_text(old_value = &quot;account&quot;, 
                          new_value = account, 
                          only_at_cursor = FALSE
    )
  #&quot;./output_%m%d_%H%M/tmp/【宋江】慰问信.docx&quot;
  print(doc_replaced, 
        target = paste0(path.tmp.dir, i,&quot;【&quot;, namePerson, &quot;】&quot;, &quot;慰问信.docx&quot;)
  )
  
  # progress msg
  print(
    paste0(i,&quot;【&quot;, namePerson, &quot;】&quot;, &quot;慰问信.docx&quot;,&quot;  created ✓&quot;)
    )
}
</code></pre>
<h2 id="merge-word-documents-into-a-single-docx-file">merge word documents into a single .docx file</h2>
<p>上一步，每个文档填入了一个Observation的信息，产生了数个文档。如果你把一个个打开，再打印，费时费力。而你肯定会被文印室的工作人员吐槽的。所以，为了减少打印设置的工作量，我们需要把所有文档，合并成一个文件，每个文档的内容之间，通过<code>分页符（page break）</code>分隔。</p>
<ul>
<li>
<p>因此，我们读取第一个输出的文档，以此为基础，依次把<code>分页符</code>和<code>下一个文档的信息</code>放入这个<code>rdocx</code>，最后<code>print</code>出来就行了。</p>
</li>
<li>
<p>有时候，默认的文件排序不是我们所需要的，比如：</p>
</li>
</ul>
<pre><code>&gt; list.files(path = path.tmp.dir)
  [1] &quot;1【宋江】慰问信.docx&quot;     &quot;10【柴进】慰问信.docx&quot;    
  [3]&quot;100【孙新】慰问信.docx&quot;   &quot;101【顾大嫂】慰问信.docx&quot;
  [5] &quot;102【张青】慰问信.docx&quot;   &quot;103【孙二娘】慰问信.docx&quot; 
  ....
</code></pre>
<p>更多的时候我们需要和.xlsx表格的数据顺序一致，比如：</p>
<pre><code>  [1] &quot;./output_0822_0956/tmp/1【宋江】慰问信.docx&quot;     
  [2] &quot;./output_0822_0956/tmp/2【卢俊义】慰问信.docx&quot;    
  [3] &quot;./output_0822_0956/tmp/3【吴用】慰问信.docx&quot;    
  ....
</code></pre>
<p>所以，这里我用正则表达式的 look behind<code>(?&lt;=pattern)</code>和look ahead positive assert<code>(?=pattern)</code>，找位于<code>tmp/</code>后面，<code>【</code>前面的字符串，也就是我们之前写在文件名中的序号，将字符串序号转换成<code>numeric()</code>，再排序<code>order()</code>。</p>
<pre><code class="language-{r}">#### merge letters into a single word doc ####
# get ordered
doc.path &lt;- paste0(path.tmp.dir, 
                  list.files(path = path.tmp.dir)
)
idx &lt;- doc.path %&gt;% str_extract_all(pattern = &quot;(?&lt;=tmp/).+?(?=【)&quot;) %&gt;% unlist() %&gt;% as.numeric() %&gt;% order() 
doc.path &lt;- doc.path[idx]

# merge doc
doc_merge &lt;- officer::read_docx(path = doc.path[1])

for(i in 2:length(doc.path)){
 doc_merge &lt;- doc_merge %&gt;%
   body_add_break() %&gt;% # add a page break into an rdocx object
   body_add_docx(src = doc.path[i]) # add content of a docx into an rdocx object
 
 print(
   paste0(i, &quot;/&quot;, length(doc.path), &quot;  merged ✓&quot;)
 )
}

 print(doc_merge, 
     target = paste0(name.dir,&quot;/&quot;, &quot;【&quot;, nrow(tt.info), &quot;】&quot;, &quot;慰问信.docx&quot;)
     )
</code></pre>
<h1 id="用r语言批量写word文档二-parallel并行运算">用R语言批量写word文档（二）—— parallel并行运算</h1>
<p>R语言默认只利用CPU单个核单线程。而显然我们<code>write word docmument</code>那一步，各个循环之间可以独立运行，不存在谁的input依赖谁的output的情况。所以，我们可以利用<code>parallel::parLapply</code>，把各个循环分给多个核多个线程，进行并行运算，以期减少等待的时间。</p>
<pre><code class="language-{r}">#### set working directory ####
# set the folder where the RScript locates as working dir (you need Rstudio to do this)
setwd(
 dirname(rstudioapi::getSourceEditorContext()$path)
)

#### load Packages ####
library(readxl)
library(officer)
library(stringr)
library(parallel) # &lt;----------

#### create output dir ####
current.time &lt;- Sys.time() # 先把时间记下来 免得程序跑得过久 前后命名不一致
name.dir &lt;- paste0(&quot;output_&quot;,
                  format(current.time, &quot;%m%d_%H%M&quot;)
)
dir.create(name.dir)

path.tmp.dir &lt;- paste(&quot;.&quot;, name.dir, &quot;tmp/&quot;, sep = &quot;/&quot;)
dir.create(path.tmp.dir)


### load tt.info &lt;-----------------------
path.tt.info &lt;- &quot;./Data/【模拟】生活困难党员摸底统计.xlsx&quot;

tt.info &lt;- readxl::read_excel(path = path.tt.info,
                             sheet = 1, skip = 0
                             )


#### def  word documents Function ####

Fun.writeDoc &lt;- function(i){
 
 # 读取 模板.docx &lt;-----------------------
 officer_doc &lt;- officer::read_docx(path = &quot;./Data/【模板】慰问信.docx&quot;)
 
 # def variable
 namePerson &lt;- tt.info$姓名[i]
 nameBank &lt;- tt.info$开户行名称[i]
 account &lt;- tt.info$`开户行账号（卡号）`[i] %&gt;% as.character()
 
 # 替换
 doc_replaced &lt;- officer_doc %&gt;%
   body_replace_all_text(old_value = &quot;namePerson&quot;, 
                         new_value = namePerson, 
                         only_at_cursor = FALSE
   ) %&gt;%
   body_replace_all_text(old_value = &quot;nameBank&quot;, 
                         new_value = nameBank, 
                         only_at_cursor = FALSE
   ) %&gt;% 
   body_replace_all_text(old_value = &quot;account&quot;, 
                         new_value = account, 
                         only_at_cursor = FALSE
   )
 #&quot;./output_%m%d_%H%M/tmp/【宋江】慰问信.docx&quot;
 print(doc_replaced, 
       target = paste0(path.tmp.dir, i,&quot;【&quot;, namePerson, &quot;】&quot;, &quot;慰问信.docx&quot;)
 )
 
# progress msg
print(
   paste0(i,&quot;【&quot;, namePerson, &quot;】&quot;, &quot;慰问信.docx&quot;,&quot;  created ✓&quot;)
   )
} # End of def Fun.writeDoc

#### def Fun.loadPackages ####
Fun.loadPackages &lt;- function(packages) {
 for (p in packages) {
   library(p, character.only=TRUE)
 }
 NULL
} 

# detectCores() # 16
#### run parLapply ####
system.time({
 
 parallel.cl &lt;- makeCluster(12) # 初始化12核心集群
 clusterExport(parallel.cl, &quot;tt.info&quot;) #将tt.info导入所有cluster
 clusterExport(parallel.cl, &quot;name.dir&quot;)
 clusterExport(parallel.cl, &quot;path.tmp.dir&quot;)
 clusterCall(parallel.cl, Fun.loadPackages, c(&quot;readxl&quot;, &quot;officer&quot;, &quot;stringr&quot;)) # load package into all clusters
 
 i = 1:nrow(tt.info)
 parLapply(cl = parallel.cl, X = i, fun = Fun.writeDoc) # lapply的并行版本
 
 stopCluster(parallel.cl) # 关闭集群
 
})
####_____________________####

#### merge letters into a single word doc ####
# get ordered
doc.path &lt;- paste0(path.tmp.dir, 
                  list.files(path = path.tmp.dir)
)
idx &lt;- doc.path %&gt;% str_extract_all(pattern = &quot;(?&lt;=tmp/).+?(?=【)&quot;) %&gt;% unlist() %&gt;% as.numeric() %&gt;% order() 
doc.path &lt;- doc.path[idx]

# merge doc
doc_merge &lt;- officer::read_docx(path = doc.path[1])

for(i in 2:length(doc.path)){
 doc_merge &lt;- doc_merge %&gt;%
   body_add_break() %&gt;% # add a page break into an rdocx object
   body_add_docx(src = doc.path[i]) # add content of a docx into an rdocx object
 
 print(
   paste0(i, &quot;/&quot;, length(doc.path), &quot;  merged ✓&quot;)
 )
}


print(doc_merge, 
     target = paste0(name.dir,&quot;/&quot;, &quot;【&quot;, nrow(tt.info), &quot;】&quot;, &quot;慰问信.docx&quot;)
)
</code></pre>
<h1 id="用r语言批量写word文档三-常见问题解决">用R语言批量写word文档（三）—— 常见问题解决</h1>
<h2 id="问题描述">问题描述</h2>
<p>前文提到：对文档多次编辑，可能会使得【标记的内容】不在同一个node，此时<code>officer::body_replace_all_text</code>会识别不出来，提示：</p>
<pre><code>In x$doc_obj$replace_all_text(old_value, new_value, only_at_cursor,  :
  Found 0 instances of '...' in the document.
</code></pre>
<h2 id="原因探究">原因探究</h2>
<p>参考：<a href="https://stackoverflow.com/questions/51047772/doesnt-work-body-replace-all-text-method-in-package-officer">David Gohel, stackoverflow的回答</a></p>
<p>我们可以用通过<code>officer::docx_show_chunk()</code>显示<code>rdocx</code> R object 每个chunk的内容。</p>
<pre><code class="language-{r}">&gt; officer_doc &lt;- officer::read_docx(path = &quot;./Data/【模板】慰问信.docx&quot;)
&gt; officer_doc %&gt;% cursor_begin() %&gt;% 
+   cursor_forward %&gt;% 
+   cursor_forward %&gt;% 
+   cursor_forward %&gt;% 
+   cursor_forward %&gt;% 
+   #cursor_forward %&gt;%
+   docx_show_chunk()
18 text nodes found at this cursor. 
 &lt;w:t&gt;: '奋斗百年路，启航新征程。希望您继续发挥'
 &lt;w:t&gt;: '党员'
 &lt;w:t&gt;: '模范带头作用，'
 &lt;w:t&gt;: '一如既往地'
 &lt;w:t&gt;: '支持全街经济社会各项工作。'
 &lt;w:t&gt;: '现将'
 &lt;w:t&gt;: '慰问金壹仟元整（'
 &lt;w:t&gt;: '1000'
 &lt;w:t&gt;: '元）'
 &lt;w:t&gt;: '汇入'
 &lt;w:t&gt;: '您的'
 &lt;w:t&gt;: 'name'
 &lt;w:t&gt;: 'B'
 &lt;w:t&gt;: 'ank'
 &lt;w:t&gt;: '账户'
 &lt;w:t&gt;: 'account'
 &lt;w:t&gt;: '，请查收'
 &lt;w:t&gt;: '。'
</code></pre>
<p>可以看到我们计划作为标记的<code>nameBank</code>被分到3个nodes中：</p>
<pre><code> &lt;w:t&gt;: 'name'
 &lt;w:t&gt;: 'B'
 &lt;w:t&gt;: 'ank'
</code></pre>
<p>这样的情况<code>officer::body_replace_all_text</code>函数识别不出来，就会提示<code>Found 0 instances of 'nameBank' in the document.</code>。</p>
<h2 id="解决办法">解决办法</h2>
<ol>
<li>
<p>把这一段的内容删去（delete）。</p>
</li>
<li>
<p>把这一段的内容粘到文本编辑器（以去除格式）</p>
</li>
<li>
<p>把文本编辑器的这一段的内容 再一块儿粘回到word文档。</p>
<p>我们会发现：我们写的标记已经位于同一chunk的同一node中了<code>&lt;w:t&gt;: 'nameBank'</code>。</p>
<pre><code>&gt; officer_doc &lt;- officer::read_docx(path = &quot;./Data/【模板】慰问信.docx&quot;)
&gt; officer_doc %&gt;% cursor_begin() %&gt;% 
+   cursor_forward %&gt;% 
+   cursor_forward %&gt;% 
+   cursor_forward %&gt;% 
+   cursor_forward %&gt;% 
+   #cursor_forward %&gt;%
+   docx_show_chunk()
7 text nodes found at this cursor. 
  &lt;w:t&gt;: '奋斗百年路，启航新征程。希望您继续发挥党员模范带头作用，一如既往地支持全街经济社会各项工作。现将慰问金壹仟元整（'
  &lt;w:t&gt;: '1000'
  &lt;w:t&gt;: '元）汇入您的'
  &lt;w:t&gt;: 'nameBank'
  &lt;w:t&gt;: '账户'
  &lt;w:t&gt;: 'account'
  &lt;w:t&gt;: '，请查收。'
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://ezrilei.github.io/post/hello-gridea/</id>
        <link href="https://ezrilei.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>